// Created by Credix - Licence: https://creativecommons.org/licenses/by-nc-sa/4.0/ 
#ifndef EVENTS_H
#define EVENTS_H

#include "../Headers/Interfaces.h"
#include "../Hacks/Settings.h"
#include "../Headers/MenuWrapper.h"

#include <vector>

class EventDisplay {
public:
	EventDisplay(IGameEvent* EVENT, float DISPLAYTIME) {
		fDisplayTime = DISPLAYTIME;
		pEvent = EVENT;
		fCurrentTime = g_pEngineClient->Time();
		/*if (_strcmpi(pEvent->GetName(), "item_purchase") == 0) {
			sprintf(text, "%i purchased %s", pEvent->GetInt("userid"), pEvent->GetString("weapon"));
			bDraw = true;
		}*/
	}
	void Draw(int index) {
		if (bDraw) {
			DrawString(5, 20 + (index * 14), text, fontSmall, color_white);
		}
	}
	IGameEvent* pEvent;
	float fCurrentTime;
	float fDisplayTime;
	char text[256] = { 0 };
	bool bDraw = false;
};

std::vector<EventDisplay*> events;

enum EventType_t {
	EVENT_PLAYER_DEATH = 0,
	EVENT_OTHER_DEATH = 1,
	EVENT_ITEM_PURCHASE = 2,
	BOMB_BEGINPLANT = 3,
	BOMB_ABORTPLANT,
	BOMB_PLANTED,
	BOMB_DEFUSED,
	BOMB_EXPLODED,
	BOMB_DROPPED,
	BOMB_PICKUP,
	DEFUSER_DROPPED,
	DEFUSER_PICKUP,
	ANNOUNCE_PHASE_END,
	CS_INTERMISSION,
	BOMB_BEGINDEFUSE,
	BOMB_ABORTDEFUSE,
	HOSTAGE_FOLLOWS,
	HOSTAGE_HURT,
	HOSTAGE_KILLED,
	HOSTAGE_RESCUED,
	HOSTAGE_STOPS_FOLLOWING,
	HOSTAGE_RESCUED_ALL,
	HOSTAGE_CALL_FOR_HELP,
	VIP_ESCAPED,
	VIP_KILLED,
	PLAYER_RADIO,
	BOMB_BEEP,
	WEAPON_FIRE,
	WEAPON_FIRE_ON_EMPTY,
	GRENADE_THROWN,
	WEAPON_OUTOFAMMO,
	WEAPON_RELOAD,
	WEAPON_ZOOM,
	SILENCER_DETACH,
	INSPECT_WEAPON,
	WEAPON_ZOOM_RIFLE,
	PLAYER_SPAWNED,
	ITEM_PICKUP,
	AMMO_PICKUP,
	ITEM_EQUIP,
	ITEM_REMOVE,
	ENTER_BUYZONE,
	EXIT_BUYZONE,
	BUYTIME_ENDED,
	ENTER_BOMBZONE,
	EXIT_BOMBZONE,
	ENTER_RESCUE_ZONE,
	EXIT_RESCUE_ZONE,
	SILENCER_OFF,
	SILENCER_ON,
	BUYMENU_OPEN,
	BUYMENU_CLOSE,
	BEGIN_NEW_MATCH,
	ROUND_PRESTART,
	ROUND_POSTSTART,
	ROUND_START,
	ROUND_END,
	ROUND_OFFICIALLY_ENDED,
	GRENADE_BOUNCE,
	HEGRENADE_DETONATE,
	FLASHBANG_DETONATE,
	SMOKEGRENADE_DETONATE,
	SMOKEGRENADE_EXPIRED,
	MOLOTOV_DETONATE,
	DECOY_DETONATE,
	DECOY_STARTED,
	TAGRENADE_DETONATE,
	INFERNO_STARTBURN,
INFERNO_EXPIRE,
INFERNO_EXTINGUISH,
DECOY_FIRING,
BULLET_IMPACT,
PLAYER_FOOTSTEP,
PLAYER_JUMP,
PLAYER_BLIND,
PLAYER_FALLDAMAGE,
DOOR_MOVING,
ROUND_FREEZE_END,
MB_INPUT_LOCK_SUCCESS,
MB_INPUT_LOCK_CANCEL,
NAV_BLOCKED,
NAV_GENERATE,
PLAYER_STATS_UPDATED,
ACHIEVEMENT_INFO_LOADED,
SPEC_TARGET_UPDATED,
SPEC_MODE_UPDATED,
HLTV_CHANGED_MODE,
HLTV_CHASE,
HLTV_STATUS,
PLAYER_DISCONNECT,
PLAYER_SPAWN,
PLAYER_TEAM,
CS_GAME_DISCONNECTED,
CS_ROUND_FINAL_BEEP,
CS_ROUND_START_BEEP,
CS_WIN_PANEL_ROUND,
CS_WIN_PANEL_MATCH,
ROUND_ANNOUNCE_LAST_ROUND_HALF,
ROUND_ANNOUNCE_MATCH_POINT,
ROUND_ANNOUNCE_WARMUP,
ROUND_ANNOUNCE_MATCH_START,
ROUND_TIME_WARNING,
CS_MATCH_END_RESTART,
CS_PRE_RESTART,
SHOW_FREEZEPANEL,
HIDE_FREEZEPANEL,
FREEZECAM_STARTED,
PLAYER_AVENGED_TEAMMATE,
ACHIEVEMENT_EARNED,
ACHIEVEMENT_EARNED_LOCAL,
ITEM_FOUND,
ITEMS_GIFTED,
REPOST_XBOX_ACHIEVEMENTS,
MATCH_END_CONDITIONS,
ROUND_MVP,
PLAYER_DECAL,
TEAMPLAY_ROUND_START,
CLIENT_DISCONNECT,
GG_PLAYER_LEVELUP,
GGTR_PLAYER_LEVELUP,
ASSASSINATION_TARGET_KILLED,
GGPROGRESSIVE_PLAYER_LEVELUP,
GG_KILLED_ENEMY,
GG_FINAL_WEAPON_ACHIEVED,
GG_BONUS_GRENADE_ACHIEVED,
SWITCH_TEAM,
GG_LEADER,
GG_TEAM_LEADER,
GG_PLAYER_IMPENDING_UPGRADE,
WRITE_PROFILE_DATA,
TRIAL_TIME_EXPIRED,
UPDATE_MATCHMAKING_STATS,
PLAYER_RESET_VOTE,
ENABLE_RESTART_VOTING,
SFUIEVENT,
START_VOTE,
PLAYER_GIVEN_C,
GG_RESET_ROUND_START_SOUNDS,
TR_PLAYER_FLASHBANGED,
TR_HIGHLIGHT_AMMO,
TR_MARK_COMPLETE,
TR_MARK_BEST_TIME,
TR_EXIT_HINT_TRIGGER,
BOT_TAKEOVER,
TR_SHOW_FINISH_MSGBOX,
TR_SHOW_EXIT_MSGBOX,
RESET_PLAYER_CONTROLS,
JOINTEAM_FAILED,
TEAMCHANGE_PENDING,
MATERIAL_DEFAULT_COMPLETE,
CS_PREV_NEXT_SPECTATOR,
CS_HANDLE_IME_EVENT,
NEXTLEVEL_CHANGED,
EVENT_SEASONCOIN_LEVELUP,
EVENT_TOURNAMENT_REWARD,
EVENT_START_HALFTIME,
};

namespace Events {
	void AddEvent(IGameEvent* pEvent, float displayTime) {
		EventDisplay* e = new EventDisplay(pEvent, displayTime);
		events.push_back(e);
	}
	void Draw() {
		for (int i = 0; i < events.size(); i++) {
			EventDisplay* pEvent = events.at(i);
			if (pEvent && (pEvent->fCurrentTime + pEvent->fDisplayTime) >= g_pEngineClient->Time()) {
				pEvent->Draw(i);
			}
			if ((pEvent->fCurrentTime + pEvent->fDisplayTime) <= g_pEngineClient->Time()) {
				events.erase(events.begin() + i);
			}
		}
	}
};

#endif